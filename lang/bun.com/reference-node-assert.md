---
url: https://bun.com/reference/node/assert
title: Node.js assert module | API Reference | Bun
source_domain: bun.com
---

# Node.js assert module | API Reference | Bun

Node.js module

# [assert](https://bun.com/reference/node/assert)

The `'node:assert'` module provides a simple set of assertion tests for validating invariants in code. It includes functions like `assert.ok`, `assert.strictEqual`, and `assert.throws` to perform runtime checks and throw descriptive errors when assertions fail.

Assertions are commonly used in tests and internal sanity checks to ensure that expected values and conditions hold true during execution. The module supports deep equality checks, custom error messages, and strict or loose comparisons.

Works in Bun

Fully implemented.

* [export default function assert](https://bun.com/reference/node/assert/default)(

  value: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): asserts value;

  An alias of assert.ok.

  @param value

  The input that is checked for being truthy.

  ### [export default namespace assert](https://bun.com/reference/node/assert/default)

  + ### class [AssertionError](https://bun.com/reference/node/assert/default/AssertionError)

    Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.

    - [actual](https://bun.com/reference/node/assert/default/AssertionError/actual): unknown

      Set to the `actual` argument for methods such as ().
    - [cause](https://bun.com/reference/node/assert/default/AssertionError/cause)?: unknown

      The cause of the error.
    - [code](https://bun.com/reference/node/assert/default/AssertionError/code): 'ERR\_ASSERTION'

      Value is always `ERR_ASSERTION` to show that the error is an assertion error.
    - [expected](https://bun.com/reference/node/assert/default/AssertionError/expected): unknown

      Set to the `expected` argument for methods such as ().
    - [generatedMessage](https://bun.com/reference/node/assert/default/AssertionError/generatedMessage): boolean

      Indicates if the message was auto-generated (`true`) or not.
    - [message](https://bun.com/reference/node/assert/default/AssertionError/message): string
    - [name](https://bun.com/reference/node/assert/default/AssertionError/name): string
    - [operator](https://bun.com/reference/node/assert/default/AssertionError/operator): string

      Set to the passed in operator value.
    - [stack](https://bun.com/reference/node/assert/default/AssertionError/stack)?: string
    - static [stackTraceLimit](https://bun.com/reference/node/assert/default/AssertionError/stackTraceLimit): number

      The `Error.stackTraceLimit` property specifies the number of stack frames collected by a stack trace (whether generated by `new Error().stack` or `Error.captureStackTrace(obj)`).

      The default value is `10` but may be set to any valid JavaScript number. Changes will affect any stack trace captured *after* the value has been changed.

      If set to a non-number value, or set to a negative number, stack traces will not capture any frames.
    - static [captureStackTrace](https://bun.com/reference/node/assert/default/AssertionError/captureStackTrace)(

      targetObject: object,

      constructorOpt?: Function

      ): void;

      Create .stack property on a target object
    - static [isError](https://bun.com/reference/node/assert/default/AssertionError/isError)(

      value: unknown

      ): value is [Error](https://bun.com/reference/globals/Error);

      Check if a value is an instance of Error

      @param value

      The value to check

      @returns

      True if the value is an instance of Error, false otherwise
    - static [prepareStackTrace](https://bun.com/reference/node/assert/default/AssertionError/prepareStackTrace)(

      err: [Error](https://bun.com/reference/globals/Error),

      stackTraces: CallSite[]

      ): any;
  + ### interface [Assert](https://bun.com/reference/node/assert/default/Assert)

    - readonly [[kOptions]](https://bun.com/reference/node/assert/default/Assert/[kOptions]): [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: false }
    - [deepEqual](https://bun.com/reference/node/assert/default/Assert/deepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [deepStrictEqual](https://bun.com/reference/node/assert/default/Assert/deepStrictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [doesNotMatch](https://bun.com/reference/node/assert/default/Assert/doesNotMatch): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [doesNotReject](https://bun.com/reference/node/assert/default/Assert/doesNotReject): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
    - [doesNotThrow](https://bun.com/reference/node/assert/default/Assert/doesNotThrow): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
    - [equal](https://bun.com/reference/node/assert/default/Assert/equal): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [fail](https://bun.com/reference/node/assert/default/Assert/fail): {}
    - [ifError](https://bun.com/reference/node/assert/default/Assert/ifError): (value: unknown) => asserts value is undefined | null
    - [match](https://bun.com/reference/node/assert/default/Assert/match): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notDeepEqual](https://bun.com/reference/node/assert/default/Assert/notDeepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notDeepStrictEqual](https://bun.com/reference/node/assert/default/Assert/notDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notEqual](https://bun.com/reference/node/assert/default/Assert/notEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notStrictEqual](https://bun.com/reference/node/assert/default/Assert/notStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [ok](https://bun.com/reference/node/assert/default/Assert/ok): (value: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts value
    - [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/Assert/partialDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [rejects](https://bun.com/reference/node/assert/default/Assert/rejects): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
    - [strictEqual](https://bun.com/reference/node/assert/default/Assert/strictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [throws](https://bun.com/reference/node/assert/default/Assert/throws): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
  + ### interface [AssertionErrorOptions](https://bun.com/reference/node/assert/default/AssertionErrorOptions)

    - [actual](https://bun.com/reference/node/assert/default/AssertionErrorOptions/actual)?: unknown

      The `actual` property on the error instance.
    - [diff](https://bun.com/reference/node/assert/default/AssertionErrorOptions/diff)?: 'simple' | 'full'

      If set to `'full'`, shows the full diff in assertion errors.
    - [expected](https://bun.com/reference/node/assert/default/AssertionErrorOptions/expected)?: unknown

      The `expected` property on the error instance.
    - [message](https://bun.com/reference/node/assert/default/AssertionErrorOptions/message)?: string

      If provided, the error message is set to this value.
    - [operator](https://bun.com/reference/node/assert/default/AssertionErrorOptions/operator)?: string

      The `operator` property on the error instance.
    - [stackStartFn](https://bun.com/reference/node/assert/default/AssertionErrorOptions/stackStartFn)?: Function

      If provided, the generated stack trace omits frames before this function.
  + ### interface [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions)

    - [diff](https://bun.com/reference/node/assert/default/AssertOptions/diff)?: 'simple' | 'full'

      If set to `'full'`, shows the full diff in assertion errors.
    - [skipPrototype](https://bun.com/reference/node/assert/default/AssertOptions/skipPrototype)?: boolean

      If set to `true`, skips prototype and constructor comparison in deep equality checks.
    - [strict](https://bun.com/reference/node/assert/default/AssertOptions/strict)?: boolean

      If set to `true`, non-strict methods behave like their corresponding strict methods.
  + ### interface [AssertStrict](https://bun.com/reference/node/assert/default/AssertStrict)

    - readonly [[kOptions]](https://bun.com/reference/node/assert/default/AssertStrict/[kOptions]): [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: true }
    - [deepEqual](https://bun.com/reference/node/assert/default/AssertStrict/deepEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [deepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/deepStrictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [doesNotMatch](https://bun.com/reference/node/assert/default/AssertStrict/doesNotMatch): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [doesNotReject](https://bun.com/reference/node/assert/default/AssertStrict/doesNotReject): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
    - [doesNotThrow](https://bun.com/reference/node/assert/default/AssertStrict/doesNotThrow): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
    - [equal](https://bun.com/reference/node/assert/default/AssertStrict/equal): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [fail](https://bun.com/reference/node/assert/default/AssertStrict/fail): {}
    - [ifError](https://bun.com/reference/node/assert/default/AssertStrict/ifError): (value: unknown) => asserts value is undefined | null
    - [match](https://bun.com/reference/node/assert/default/AssertStrict/match): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notDeepEqual](https://bun.com/reference/node/assert/default/AssertStrict/notDeepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notDeepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/notDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notEqual](https://bun.com/reference/node/assert/default/AssertStrict/notEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [notStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/notStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [ok](https://bun.com/reference/node/assert/default/AssertStrict/ok): (value: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts value
    - [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/partialDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
    - [rejects](https://bun.com/reference/node/assert/default/AssertStrict/rejects): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
    - [strictEqual](https://bun.com/reference/node/assert/default/AssertStrict/strictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
    - [throws](https://bun.com/reference/node/assert/default/AssertStrict/throws): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
  + ### interface [CallTrackerCall](https://bun.com/reference/node/assert/default/CallTrackerCall)

    - [arguments](https://bun.com/reference/node/assert/default/CallTrackerCall/arguments): unknown[]
    - [thisArg](https://bun.com/reference/node/assert/default/CallTrackerCall/thisArg): object
  + ### interface [CallTrackerReportInformation](https://bun.com/reference/node/assert/default/CallTrackerReportInformation)

    - [actual](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/actual): number

      The actual number of times the function was called.
    - [expected](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/expected): number

      The number of times the function was expected to be called.
    - [message](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/message): string
    - [operator](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/operator): string

      The name of the function that is wrapped.
    - [stack](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/stack): object

      A stack trace of the function.
  + type [AssertMethodNames](https://bun.com/reference/node/assert/default/AssertMethodNames) = 'deepEqual' | 'deepStrictEqual' | 'doesNotMatch' | 'doesNotReject' | 'doesNotThrow' | 'equal' | 'fail' | 'ifError' | 'match' | 'notDeepEqual' | 'notDeepStrictEqual' | 'notEqual' | 'notStrictEqual' | 'ok' | 'partialDeepStrictEqual' | 'rejects' | 'strictEqual' | 'throws'
  + type [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate) = RegExp | new () => object | (thrown: unknown) => boolean | object | [Error](https://bun.com/reference/globals/Error)
  + const [Assert](https://bun.com/reference/node/assert/default/Assert): {new (options?: [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: true }) => [AssertStrict](https://bun.com/reference/node/assert/default/AssertStrict); new (options: [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions)) => [Assert](https://bun.com/reference/node/assert/default/Assert)}

    The `Assert` class allows creating independent assertion instances with custom options.
  + function [deepEqual](https://bun.com/reference/node/assert/default/deepEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    **Strict assertion mode**

    An alias of deepStrictEqual.

    **Legacy assertion mode**

    Stability: 3 - Legacy: Use deepStrictEqual instead.

    Tests for deep equality between the `actual` and `expected` parameters. Consider using deepStrictEqual instead. deepEqual can have surprising results.

    *Deep equality* means that the enumerable "own" properties of child objects are also recursively evaluated by the following rules.
  + function [deepStrictEqual](https://bun.com/reference/node/assert/default/deepStrictEqual)<T>(

    actual: unknown,

    expected: T,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): asserts actual is T;

    Tests for deep equality between the `actual` and `expected` parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules.
  + function [doesNotMatch](https://bun.com/reference/node/assert/default/doesNotMatch)(

    value: string,

    regExp: RegExp,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Expects the `string` input not to match the regular expression.

    ```
    import assert from 'node:assert/strict';

    assert.doesNotMatch('I will fail', /fail/);
    // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...

    assert.doesNotMatch(123, /pass/);
    // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.

    assert.doesNotMatch('I will pass', /different/);
    // OK
    ```

    If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
  + function [doesNotReject](https://bun.com/reference/node/assert/default/doesNotReject)(

    block: Promise<unknown> | () => Promise<unknown>,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): Promise<void>;

    Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.

    If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.doesNotReject()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

    Using `assert.doesNotReject()` is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

    Besides the async nature to await the completion behaves identically to doesNotThrow.

    ```
    import assert from 'node:assert/strict';

    await assert.doesNotReject(
      async () => {
        throw new TypeError('Wrong value');
      },
      SyntaxError,
    );
    ```

    ```
    import assert from 'node:assert/strict';

    assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
      .then(() => {
        // ...
      });
    ```

    function [doesNotReject](https://bun.com/reference/node/assert/default/doesNotReject)(

    block: Promise<unknown> | () => Promise<unknown>,

    error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): Promise<void>;

    Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.

    If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.doesNotReject()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

    Using `assert.doesNotReject()` is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

    Besides the async nature to await the completion behaves identically to doesNotThrow.

    ```
    import assert from 'node:assert/strict';

    await assert.doesNotReject(
      async () => {
        throw new TypeError('Wrong value');
      },
      SyntaxError,
    );
    ```

    ```
    import assert from 'node:assert/strict';

    assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
      .then(() => {
        // ...
      });
    ```
  + function [doesNotThrow](https://bun.com/reference/node/assert/default/doesNotThrow)(

    block: () => unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Asserts that the function `fn` does not throw an error.

    Using `assert.doesNotThrow()` is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

    When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.

    If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a different type, or if the `error` parameter is undefined, the error is propagated back to the caller.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

    The following, for instance, will throw the `TypeError` because there is no matching error type in the assertion:

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      SyntaxError,
    );
    ```

    However, the following will result in an `AssertionError` with the message 'Got unwanted exception...':

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      TypeError,
    );
    ```

    If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      /Wrong value/,
      'Whoops',
    );
    // Throws: AssertionError: Got unwanted exception: Whoops
    ```

    function [doesNotThrow](https://bun.com/reference/node/assert/default/doesNotThrow)(

    block: () => unknown,

    error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Asserts that the function `fn` does not throw an error.

    Using `assert.doesNotThrow()` is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

    When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.

    If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a different type, or if the `error` parameter is undefined, the error is propagated back to the caller.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

    The following, for instance, will throw the `TypeError` because there is no matching error type in the assertion:

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      SyntaxError,
    );
    ```

    However, the following will result in an `AssertionError` with the message 'Got unwanted exception...':

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      TypeError,
    );
    ```

    If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:

    ```
    import assert from 'node:assert/strict';

    assert.doesNotThrow(
      () => {
        throw new TypeError('Wrong value');
      },
      /Wrong value/,
      'Whoops',
    );
    // Throws: AssertionError: Got unwanted exception: Whoops
    ```
  + function [equal](https://bun.com/reference/node/assert/default/equal)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    **Strict assertion mode**

    An alias of strictEqual.

    **Legacy assertion mode**

    Stability: 3 - Legacy: Use strictEqual instead.

    Tests shallow, coercive equality between the `actual` and `expected` parameters using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled and treated as being identical if both sides are `NaN`.

    ```
    import assert from 'node:assert';

    assert.equal(1, 1);
    // OK, 1 == 1
    assert.equal(1, '1');
    // OK, 1 == '1'
    assert.equal(NaN, NaN);
    // OK

    assert.equal(1, 2);
    // AssertionError: 1 == 2
    assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
    // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
    ```

    If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [ifError](https://bun.com/reference/node/assert/default/ifError)(

    value: unknown

    ): asserts value is undefined | null;

    Throws `value` if `value` is not `undefined` or `null`. This is useful when testing the `error` argument in callbacks. The stack trace contains all frames from the error passed to `ifError()` including the potential new frames for `ifError()` itself.

    ```
    import assert from 'node:assert/strict';

    assert.ifError(null);
    // OK
    assert.ifError(0);
    // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
    assert.ifError('error');
    // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
    assert.ifError(new Error());
    // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error

    // Create some random error frames.
    let err;
    (function errorFrame() {
      err = new Error('test error');
    })();

    (function ifErrorFrame() {
      assert.ifError(err);
    })();
    // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
    //     at ifErrorFrame
    //     at errorFrame
    ```
  + function [match](https://bun.com/reference/node/assert/default/match)(

    value: string,

    regExp: RegExp,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Expects the `string` input to match the regular expression.

    ```
    import assert from 'node:assert/strict';

    assert.match('I will fail', /pass/);
    // AssertionError [ERR_ASSERTION]: The input did not match the regular ...

    assert.match(123, /pass/);
    // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.

    assert.match('I will pass', /pass/);
    // OK
    ```

    If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
  + function [notDeepEqual](https://bun.com/reference/node/assert/default/notDeepEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    **Strict assertion mode**

    An alias of notDeepStrictEqual.

    **Legacy assertion mode**

    Stability: 3 - Legacy: Use notDeepStrictEqual instead.

    Tests for any deep inequality. Opposite of deepEqual.

    ```
    import assert from 'node:assert';

    const obj1 = {
      a: {
        b: 1,
      },
    };
    const obj2 = {
      a: {
        b: 2,
      },
    };
    const obj3 = {
      a: {
        b: 1,
      },
    };
    const obj4 = { __proto__: obj1 };

    assert.notDeepEqual(obj1, obj1);
    // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

    assert.notDeepEqual(obj1, obj2);
    // OK

    assert.notDeepEqual(obj1, obj3);
    // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

    assert.notDeepEqual(obj1, obj4);
    // OK
    ```

    If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [notDeepStrictEqual](https://bun.com/reference/node/assert/default/notDeepStrictEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Tests for deep strict inequality. Opposite of deepStrictEqual.

    ```
    import assert from 'node:assert/strict';

    assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
    // OK
    ```

    If the values are deeply and strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [notEqual](https://bun.com/reference/node/assert/default/notEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    **Strict assertion mode**

    An alias of notStrictEqual.

    **Legacy assertion mode**

    Stability: 3 - Legacy: Use notStrictEqual instead.

    Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is specially handled and treated as being identical if both sides are `NaN`.

    ```
    import assert from 'node:assert';

    assert.notEqual(1, 2);
    // OK

    assert.notEqual(1, 1);
    // AssertionError: 1 != 1

    assert.notEqual(1, '1');
    // AssertionError: 1 != '1'
    ```

    If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [notStrictEqual](https://bun.com/reference/node/assert/default/notStrictEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Tests strict inequality between the `actual` and `expected` parameters as determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).

    ```
    import assert from 'node:assert/strict';

    assert.notStrictEqual(1, 2);
    // OK

    assert.notStrictEqual(1, 1);
    // AssertionError [ERR_ASSERTION]: Expected "actual" to be strictly unequal to:
    //
    // 1

    assert.notStrictEqual(1, '1');
    // OK
    ```

    If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [ok](https://bun.com/reference/node/assert/default/ok)(

    value: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): asserts value;

    Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.

    If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`. If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.

    Be aware that in the `repl` the error message will be different to the one thrown in a file! See below for further details.

    ```
    import assert from 'node:assert/strict';

    assert.ok(true);
    // OK
    assert.ok(1);
    // OK

    assert.ok();
    // AssertionError: No value argument passed to `assert.ok()`

    assert.ok(false, 'it\'s false');
    // AssertionError: it's false

    // In the repl:
    assert.ok(typeof 123 === 'string');
    // AssertionError: false == true

    // In a file (e.g. test.js):
    assert.ok(typeof 123 === 'string');
    // AssertionError: The expression evaluated to a falsy value:
    //
    //   assert.ok(typeof 123 === 'string')

    assert.ok(false);
    // AssertionError: The expression evaluated to a falsy value:
    //
    //   assert.ok(false)

    assert.ok(0);
    // AssertionError: The expression evaluated to a falsy value:
    //
    //   assert.ok(0)
    ```

    ```
    import assert from 'node:assert/strict';

    // Using `assert()` works the same:
    assert(0);
    // AssertionError: The expression evaluated to a falsy value:
    //
    //   assert(0)
    ```
  + function [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/partialDeepStrictEqual)(

    actual: unknown,

    expected: unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Tests for partial deep equality between the `actual` and `expected` parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules. "Partial" equality means that only properties that exist on the `expected` parameter are going to be compared.

    This method always passes the same test cases as `assert.deepStrictEqual()`, behaving as a super set of it.
  + function [rejects](https://bun.com/reference/node/assert/default/rejects)(

    block: Promise<unknown> | () => Promise<unknown>,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): Promise<void>;

    Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected.

    If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

    Besides the async nature to await the completion behaves identically to throws.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable `message` and `name` properties.

    If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.

    ```
    import assert from 'node:assert/strict';

    await assert.rejects(
      async () => {
        throw new TypeError('Wrong value');
      },
      {
        name: 'TypeError',
        message: 'Wrong value',
      },
    );
    ```

    ```
    import assert from 'node:assert/strict';

    await assert.rejects(
      async () => {
        throw new TypeError('Wrong value');
      },
      (err) => {
        assert.strictEqual(err.name, 'TypeError');
        assert.strictEqual(err.message, 'Wrong value');
        return true;
      },
    );
    ```

    ```
    import assert from 'node:assert/strict';

    assert.rejects(
      Promise.reject(new Error('Wrong value')),
      Error,
    ).then(() => {
      // ...
    });
    ```

    `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the example in throws carefully if using a string as the second argument gets considered.

    function [rejects](https://bun.com/reference/node/assert/default/rejects)(

    block: Promise<unknown> | () => Promise<unknown>,

    error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): Promise<void>;

    Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected.

    If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

    Besides the async nature to await the completion behaves identically to throws.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable `message` and `name` properties.

    If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.

    ```
    import assert from 'node:assert/strict';

    await assert.rejects(
      async () => {
        throw new TypeError('Wrong value');
      },
      {
        name: 'TypeError',
        message: 'Wrong value',
      },
    );
    ```

    ```
    import assert from 'node:assert/strict';

    await assert.rejects(
      async () => {
        throw new TypeError('Wrong value');
      },
      (err) => {
        assert.strictEqual(err.name, 'TypeError');
        assert.strictEqual(err.message, 'Wrong value');
        return true;
      },
    );
    ```

    ```
    import assert from 'node:assert/strict';

    assert.rejects(
      Promise.reject(new Error('Wrong value')),
      Error,
    ).then(() => {
      // ...
    });
    ```

    `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the example in throws carefully if using a string as the second argument gets considered.
  + function [strictEqual](https://bun.com/reference/node/assert/default/strictEqual)<T>(

    actual: unknown,

    expected: T,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): asserts actual is T;

    Tests strict equality between the `actual` and `expected` parameters as determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).

    ```
    import assert from 'node:assert/strict';

    assert.strictEqual(1, 2);
    // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
    //
    // 1 !== 2

    assert.strictEqual(1, 1);
    // OK

    assert.strictEqual('Hello foobar', 'Hello World!');
    // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
    // + actual - expected
    //
    // + 'Hello foobar'
    // - 'Hello World!'
    //          ^

    const apples = 1;
    const oranges = 2;
    assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);
    // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2

    assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));
    // TypeError: Inputs are not identical
    ```

    If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
  + function [throws](https://bun.com/reference/node/assert/default/throws)(

    block: () => unknown,

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Expects the function `fn` to throw an error.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable `message` and `name` properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.

    If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation fails.

    Custom validation object/error instance:

    ```
    import assert from 'node:assert/strict';

    const err = new TypeError('Wrong value');
    err.code = 404;
    err.foo = 'bar';
    err.info = {
      nested: true,
      baz: 'text',
    };
    err.reg = /abc/i;

    assert.throws(
      () => {
        throw err;
      },
      {
        name: 'TypeError',
        message: 'Wrong value',
        info: {
          nested: true,
          baz: 'text',
        },
        // Only properties on the validation object will be tested for.
        // Using nested objects requires all properties to be present. Otherwise
        // the validation is going to fail.
      },
    );

    // Using regular expressions to validate error properties:
    assert.throws(
      () => {
        throw err;
      },
      {
        // The `name` and `message` properties are strings and using regular
        // expressions on those will match against the string. If they fail, an
        // error is thrown.
        name: /^TypeError$/,
        message: /Wrong/,
        foo: 'bar',
        info: {
          nested: true,
          // It is not possible to use regular expressions for nested properties!
          baz: 'text',
        },
        // The `reg` property contains a regular expression and only if the
        // validation object contains an identical regular expression, it is going
        // to pass.
        reg: /abc/i,
      },
    );

    // Fails due to the different `message` and `name` properties:
    assert.throws(
      () => {
        const otherErr = new Error('Not found');
        // Copy all enumerable properties from `err` to `otherErr`.
        for (const [key, value] of Object.entries(err)) {
          otherErr[key] = value;
        }
        throw otherErr;
      },
      // The error's `message` and `name` properties will also be checked when using
      // an error as validation object.
      err,
    );
    ```

    Validate instanceof using constructor:

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      Error,
    );
    ```

    Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):

    Using a regular expression runs `.toString` on the error object, and will therefore also include the error name.

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      /^Error: Wrong value$/,
    );
    ```

    Custom error validation:

    The function must return `true` to indicate all internal validations passed. It will otherwise fail with an `AssertionError`.

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      (err) => {
        assert(err instanceof Error);
        assert(/value/.test(err));
        // Avoid returning anything from validation functions besides `true`.
        // Otherwise, it's not clear what part of the validation failed. Instead,
        // throw an error about the specific validation that failed (as done in this
        // example) and add as much helpful debugging information to that error as
        // possible.
        return true;
      },
      'unexpected error',
    );
    ```

    `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using a string as the second argument gets considered:

    ```
    import assert from 'node:assert/strict';

    function throwingFirst() {
      throw new Error('First');
    }

    function throwingSecond() {
      throw new Error('Second');
    }

    function notThrowing() {}

    // The second argument is a string and the input function threw an Error.
    // The first case will not throw as it does not match for the error message
    // thrown by the input function!
    assert.throws(throwingFirst, 'Second');
    // In the next example the message has no benefit over the message from the
    // error and since it is not clear if the user intended to actually match
    // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
    assert.throws(throwingSecond, 'Second');
    // TypeError [ERR_AMBIGUOUS_ARGUMENT]

    // The string is only used (as message) in case the function does not throw:
    assert.throws(notThrowing, 'Second');
    // AssertionError [ERR_ASSERTION]: Missing expected exception: Second

    // If it was intended to match for the error message do this instead:
    // It does not throw because the error messages match.
    assert.throws(throwingSecond, /Second$/);

    // If the error message does not match, an AssertionError is thrown.
    assert.throws(throwingFirst, /Second$/);
    // AssertionError [ERR_ASSERTION]
    ```

    Due to the confusing error-prone notation, avoid a string as the second argument.

    function [throws](https://bun.com/reference/node/assert/default/throws)(

    block: () => unknown,

    error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

    message?: string | [Error](https://bun.com/reference/globals/Error)

    ): void;

    Expects the function `fn` to throw an error.

    If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable `message` and `name` properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.

    If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation fails.

    Custom validation object/error instance:

    ```
    import assert from 'node:assert/strict';

    const err = new TypeError('Wrong value');
    err.code = 404;
    err.foo = 'bar';
    err.info = {
      nested: true,
      baz: 'text',
    };
    err.reg = /abc/i;

    assert.throws(
      () => {
        throw err;
      },
      {
        name: 'TypeError',
        message: 'Wrong value',
        info: {
          nested: true,
          baz: 'text',
        },
        // Only properties on the validation object will be tested for.
        // Using nested objects requires all properties to be present. Otherwise
        // the validation is going to fail.
      },
    );

    // Using regular expressions to validate error properties:
    assert.throws(
      () => {
        throw err;
      },
      {
        // The `name` and `message` properties are strings and using regular
        // expressions on those will match against the string. If they fail, an
        // error is thrown.
        name: /^TypeError$/,
        message: /Wrong/,
        foo: 'bar',
        info: {
          nested: true,
          // It is not possible to use regular expressions for nested properties!
          baz: 'text',
        },
        // The `reg` property contains a regular expression and only if the
        // validation object contains an identical regular expression, it is going
        // to pass.
        reg: /abc/i,
      },
    );

    // Fails due to the different `message` and `name` properties:
    assert.throws(
      () => {
        const otherErr = new Error('Not found');
        // Copy all enumerable properties from `err` to `otherErr`.
        for (const [key, value] of Object.entries(err)) {
          otherErr[key] = value;
        }
        throw otherErr;
      },
      // The error's `message` and `name` properties will also be checked when using
      // an error as validation object.
      err,
    );
    ```

    Validate instanceof using constructor:

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      Error,
    );
    ```

    Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):

    Using a regular expression runs `.toString` on the error object, and will therefore also include the error name.

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      /^Error: Wrong value$/,
    );
    ```

    Custom error validation:

    The function must return `true` to indicate all internal validations passed. It will otherwise fail with an `AssertionError`.

    ```
    import assert from 'node:assert/strict';

    assert.throws(
      () => {
        throw new Error('Wrong value');
      },
      (err) => {
        assert(err instanceof Error);
        assert(/value/.test(err));
        // Avoid returning anything from validation functions besides `true`.
        // Otherwise, it's not clear what part of the validation failed. Instead,
        // throw an error about the specific validation that failed (as done in this
        // example) and add as much helpful debugging information to that error as
        // possible.
        return true;
      },
      'unexpected error',
    );
    ```

    `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using a string as the second argument gets considered:

    ```
    import assert from 'node:assert/strict';

    function throwingFirst() {
      throw new Error('First');
    }

    function throwingSecond() {
      throw new Error('Second');
    }

    function notThrowing() {}

    // The second argument is a string and the input function threw an Error.
    // The first case will not throw as it does not match for the error message
    // thrown by the input function!
    assert.throws(throwingFirst, 'Second');
    // In the next example the message has no benefit over the message from the
    // error and since it is not clear if the user intended to actually match
    // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
    assert.throws(throwingSecond, 'Second');
    // TypeError [ERR_AMBIGUOUS_ARGUMENT]

    // The string is only used (as message) in case the function does not throw:
    assert.throws(notThrowing, 'Second');
    // AssertionError [ERR_ASSERTION]: Missing expected exception: Second

    // If it was intended to match for the error message do this instead:
    // It does not throw because the error messages match.
    assert.throws(throwingSecond, /Second$/);

    // If the error message does not match, an AssertionError is thrown.
    assert.throws(throwingFirst, /Second$/);
    // AssertionError [ERR_ASSERTION]
    ```

    Due to the confusing error-prone notation, avoid a string as the second argument.
* [export default function assert](https://bun.com/reference/node/assert/default)(

  value: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): asserts value;

  An alias of assert.ok.

  @param value

  The input that is checked for being truthy.

  ### class [AssertionError](https://bun.com/reference/node/assert/default/AssertionError)

  Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.

  + [actual](https://bun.com/reference/node/assert/default/AssertionError/actual): unknown

    Set to the `actual` argument for methods such as ().
  + [cause](https://bun.com/reference/node/assert/default/AssertionError/cause)?: unknown

    The cause of the error.
  + [code](https://bun.com/reference/node/assert/default/AssertionError/code): 'ERR\_ASSERTION'

    Value is always `ERR_ASSERTION` to show that the error is an assertion error.
  + [expected](https://bun.com/reference/node/assert/default/AssertionError/expected): unknown

    Set to the `expected` argument for methods such as ().
  + [generatedMessage](https://bun.com/reference/node/assert/default/AssertionError/generatedMessage): boolean

    Indicates if the message was auto-generated (`true`) or not.
  + [message](https://bun.com/reference/node/assert/default/AssertionError/message): string
  + [name](https://bun.com/reference/node/assert/default/AssertionError/name): string
  + [operator](https://bun.com/reference/node/assert/default/AssertionError/operator): string

    Set to the passed in operator value.
  + [stack](https://bun.com/reference/node/assert/default/AssertionError/stack)?: string
  + static [stackTraceLimit](https://bun.com/reference/node/assert/default/AssertionError/stackTraceLimit): number

    The `Error.stackTraceLimit` property specifies the number of stack frames collected by a stack trace (whether generated by `new Error().stack` or `Error.captureStackTrace(obj)`).

    The default value is `10` but may be set to any valid JavaScript number. Changes will affect any stack trace captured *after* the value has been changed.

    If set to a non-number value, or set to a negative number, stack traces will not capture any frames.
  + static [captureStackTrace](https://bun.com/reference/node/assert/default/AssertionError/captureStackTrace)(

    targetObject: object,

    constructorOpt?: Function

    ): void;

    Create .stack property on a target object
  + static [isError](https://bun.com/reference/node/assert/default/AssertionError/isError)(

    value: unknown

    ): value is [Error](https://bun.com/reference/globals/Error);

    Check if a value is an instance of Error

    @param value

    The value to check

    @returns

    True if the value is an instance of Error, false otherwise
  + static [prepareStackTrace](https://bun.com/reference/node/assert/default/AssertionError/prepareStackTrace)(

    err: [Error](https://bun.com/reference/globals/Error),

    stackTraces: CallSite[]

    ): any;

  ### interface [Assert](https://bun.com/reference/node/assert/default/Assert)

  + readonly [[kOptions]](https://bun.com/reference/node/assert/default/Assert/[kOptions]): [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: false }
  + [deepEqual](https://bun.com/reference/node/assert/default/Assert/deepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [deepStrictEqual](https://bun.com/reference/node/assert/default/Assert/deepStrictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [doesNotMatch](https://bun.com/reference/node/assert/default/Assert/doesNotMatch): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [doesNotReject](https://bun.com/reference/node/assert/default/Assert/doesNotReject): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
  + [doesNotThrow](https://bun.com/reference/node/assert/default/Assert/doesNotThrow): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
  + [equal](https://bun.com/reference/node/assert/default/Assert/equal): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [fail](https://bun.com/reference/node/assert/default/Assert/fail): {}
  + [ifError](https://bun.com/reference/node/assert/default/Assert/ifError): (value: unknown) => asserts value is undefined | null
  + [match](https://bun.com/reference/node/assert/default/Assert/match): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notDeepEqual](https://bun.com/reference/node/assert/default/Assert/notDeepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notDeepStrictEqual](https://bun.com/reference/node/assert/default/Assert/notDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notEqual](https://bun.com/reference/node/assert/default/Assert/notEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notStrictEqual](https://bun.com/reference/node/assert/default/Assert/notStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [ok](https://bun.com/reference/node/assert/default/Assert/ok): (value: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts value
  + [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/Assert/partialDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [rejects](https://bun.com/reference/node/assert/default/Assert/rejects): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
  + [strictEqual](https://bun.com/reference/node/assert/default/Assert/strictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [throws](https://bun.com/reference/node/assert/default/Assert/throws): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}

  ### interface [AssertionErrorOptions](https://bun.com/reference/node/assert/default/AssertionErrorOptions)

  + [actual](https://bun.com/reference/node/assert/default/AssertionErrorOptions/actual)?: unknown

    The `actual` property on the error instance.
  + [diff](https://bun.com/reference/node/assert/default/AssertionErrorOptions/diff)?: 'simple' | 'full'

    If set to `'full'`, shows the full diff in assertion errors.
  + [expected](https://bun.com/reference/node/assert/default/AssertionErrorOptions/expected)?: unknown

    The `expected` property on the error instance.
  + [message](https://bun.com/reference/node/assert/default/AssertionErrorOptions/message)?: string

    If provided, the error message is set to this value.
  + [operator](https://bun.com/reference/node/assert/default/AssertionErrorOptions/operator)?: string

    The `operator` property on the error instance.
  + [stackStartFn](https://bun.com/reference/node/assert/default/AssertionErrorOptions/stackStartFn)?: Function

    If provided, the generated stack trace omits frames before this function.

  ### interface [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions)

  + [diff](https://bun.com/reference/node/assert/default/AssertOptions/diff)?: 'simple' | 'full'

    If set to `'full'`, shows the full diff in assertion errors.
  + [skipPrototype](https://bun.com/reference/node/assert/default/AssertOptions/skipPrototype)?: boolean

    If set to `true`, skips prototype and constructor comparison in deep equality checks.
  + [strict](https://bun.com/reference/node/assert/default/AssertOptions/strict)?: boolean

    If set to `true`, non-strict methods behave like their corresponding strict methods.

  ### interface [AssertStrict](https://bun.com/reference/node/assert/default/AssertStrict)

  + readonly [[kOptions]](https://bun.com/reference/node/assert/default/AssertStrict/[kOptions]): [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: true }
  + [deepEqual](https://bun.com/reference/node/assert/default/AssertStrict/deepEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [deepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/deepStrictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [doesNotMatch](https://bun.com/reference/node/assert/default/AssertStrict/doesNotMatch): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [doesNotReject](https://bun.com/reference/node/assert/default/AssertStrict/doesNotReject): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
  + [doesNotThrow](https://bun.com/reference/node/assert/default/AssertStrict/doesNotThrow): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}
  + [equal](https://bun.com/reference/node/assert/default/AssertStrict/equal): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [fail](https://bun.com/reference/node/assert/default/AssertStrict/fail): {}
  + [ifError](https://bun.com/reference/node/assert/default/AssertStrict/ifError): (value: unknown) => asserts value is undefined | null
  + [match](https://bun.com/reference/node/assert/default/AssertStrict/match): (value: string, regExp: RegExp, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notDeepEqual](https://bun.com/reference/node/assert/default/AssertStrict/notDeepEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notDeepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/notDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notEqual](https://bun.com/reference/node/assert/default/AssertStrict/notEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [notStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/notStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [ok](https://bun.com/reference/node/assert/default/AssertStrict/ok): (value: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts value
  + [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/AssertStrict/partialDeepStrictEqual): (actual: unknown, expected: unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void
  + [rejects](https://bun.com/reference/node/assert/default/AssertStrict/rejects): {(block: Promise<unknown> | () => Promise<unknown>, message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>; (block: Promise<unknown> | () => Promise<unknown>, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => Promise<void>}
  + [strictEqual](https://bun.com/reference/node/assert/default/AssertStrict/strictEqual): (actual: unknown, expected: T, message?: string | [Error](https://bun.com/reference/globals/Error)) => asserts actual is T
  + [throws](https://bun.com/reference/node/assert/default/AssertStrict/throws): {(block: () => unknown, message?: string | [Error](https://bun.com/reference/globals/Error)) => void; (block: () => unknown, error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate), message?: string | [Error](https://bun.com/reference/globals/Error)) => void}

  ### interface [CallTrackerCall](https://bun.com/reference/node/assert/default/CallTrackerCall)

  + [arguments](https://bun.com/reference/node/assert/default/CallTrackerCall/arguments): unknown[]
  + [thisArg](https://bun.com/reference/node/assert/default/CallTrackerCall/thisArg): object

  ### interface [CallTrackerReportInformation](https://bun.com/reference/node/assert/default/CallTrackerReportInformation)

  + [actual](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/actual): number

    The actual number of times the function was called.
  + [expected](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/expected): number

    The number of times the function was expected to be called.
  + [message](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/message): string
  + [operator](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/operator): string

    The name of the function that is wrapped.
  + [stack](https://bun.com/reference/node/assert/default/CallTrackerReportInformation/stack): object

    A stack trace of the function.

  type [AssertMethodNames](https://bun.com/reference/node/assert/default/AssertMethodNames) = 'deepEqual' | 'deepStrictEqual' | 'doesNotMatch' | 'doesNotReject' | 'doesNotThrow' | 'equal' | 'fail' | 'ifError' | 'match' | 'notDeepEqual' | 'notDeepStrictEqual' | 'notEqual' | 'notStrictEqual' | 'ok' | 'partialDeepStrictEqual' | 'rejects' | 'strictEqual' | 'throws'

  type [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate) = RegExp | new () => object | (thrown: unknown) => boolean | object | [Error](https://bun.com/reference/globals/Error)

  const [Assert](https://bun.com/reference/node/assert/default/Assert): {new (options?: [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions) & { strict: true }) => [AssertStrict](https://bun.com/reference/node/assert/default/AssertStrict); new (options: [AssertOptions](https://bun.com/reference/node/assert/default/AssertOptions)) => [Assert](https://bun.com/reference/node/assert/default/Assert)}

  The `Assert` class allows creating independent assertion instances with custom options.

  function [deepEqual](https://bun.com/reference/node/assert/default/deepEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  **Strict assertion mode**

  An alias of deepStrictEqual.

  **Legacy assertion mode**

  Stability: 3 - Legacy: Use deepStrictEqual instead.

  Tests for deep equality between the `actual` and `expected` parameters. Consider using deepStrictEqual instead. deepEqual can have surprising results.

  *Deep equality* means that the enumerable "own" properties of child objects are also recursively evaluated by the following rules.

  function [deepStrictEqual](https://bun.com/reference/node/assert/default/deepStrictEqual)<T>(

  actual: unknown,

  expected: T,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): asserts actual is T;

  Tests for deep equality between the `actual` and `expected` parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules.

  function [doesNotMatch](https://bun.com/reference/node/assert/default/doesNotMatch)(

  value: string,

  regExp: RegExp,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Expects the `string` input not to match the regular expression.

  ```
  import assert from 'node:assert/strict';

  assert.doesNotMatch('I will fail', /fail/);
  // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...

  assert.doesNotMatch(123, /pass/);
  // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.

  assert.doesNotMatch('I will pass', /different/);
  // OK
  ```

  If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.

  function [doesNotReject](https://bun.com/reference/node/assert/default/doesNotReject)(

  block: Promise<unknown> | () => Promise<unknown>,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): Promise<void>;

  Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.

  If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.doesNotReject()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

  Using `assert.doesNotReject()` is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

  Besides the async nature to await the completion behaves identically to doesNotThrow.

  ```
  import assert from 'node:assert/strict';

  await assert.doesNotReject(
    async () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError,
  );
  ```

  ```
  import assert from 'node:assert/strict';

  assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
    .then(() => {
      // ...
    });
  ```

  function [doesNotReject](https://bun.com/reference/node/assert/default/doesNotReject)(

  block: Promise<unknown> | () => Promise<unknown>,

  error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): Promise<void>;

  Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected.

  If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.doesNotReject()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

  Using `assert.doesNotReject()` is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

  Besides the async nature to await the completion behaves identically to doesNotThrow.

  ```
  import assert from 'node:assert/strict';

  await assert.doesNotReject(
    async () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError,
  );
  ```

  ```
  import assert from 'node:assert/strict';

  assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
    .then(() => {
      // ...
    });
  ```

  function [doesNotThrow](https://bun.com/reference/node/assert/default/doesNotThrow)(

  block: () => unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Asserts that the function `fn` does not throw an error.

  Using `assert.doesNotThrow()` is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

  When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.

  If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a different type, or if the `error` parameter is undefined, the error is propagated back to the caller.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

  The following, for instance, will throw the `TypeError` because there is no matching error type in the assertion:

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError,
  );
  ```

  However, the following will result in an `AssertionError` with the message 'Got unwanted exception...':

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    TypeError,
  );
  ```

  If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    /Wrong value/,
    'Whoops',
  );
  // Throws: AssertionError: Got unwanted exception: Whoops
  ```

  function [doesNotThrow](https://bun.com/reference/node/assert/default/doesNotThrow)(

  block: () => unknown,

  error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Asserts that the function `fn` does not throw an error.

  Using `assert.doesNotThrow()` is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible.

  When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.

  If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a different type, or if the `error` parameter is undefined, the error is propagated back to the caller.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation function. See throws for more details.

  The following, for instance, will throw the `TypeError` because there is no matching error type in the assertion:

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    SyntaxError,
  );
  ```

  However, the following will result in an `AssertionError` with the message 'Got unwanted exception...':

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    TypeError,
  );
  ```

  If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:

  ```
  import assert from 'node:assert/strict';

  assert.doesNotThrow(
    () => {
      throw new TypeError('Wrong value');
    },
    /Wrong value/,
    'Whoops',
  );
  // Throws: AssertionError: Got unwanted exception: Whoops
  ```

  function [equal](https://bun.com/reference/node/assert/default/equal)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  **Strict assertion mode**

  An alias of strictEqual.

  **Legacy assertion mode**

  Stability: 3 - Legacy: Use strictEqual instead.

  Tests shallow, coercive equality between the `actual` and `expected` parameters using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled and treated as being identical if both sides are `NaN`.

  ```
  import assert from 'node:assert';

  assert.equal(1, 1);
  // OK, 1 == 1
  assert.equal(1, '1');
  // OK, 1 == '1'
  assert.equal(NaN, NaN);
  // OK

  assert.equal(1, 2);
  // AssertionError: 1 == 2
  assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
  // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
  ```

  If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [ifError](https://bun.com/reference/node/assert/default/ifError)(

  value: unknown

  ): asserts value is undefined | null;

  Throws `value` if `value` is not `undefined` or `null`. This is useful when testing the `error` argument in callbacks. The stack trace contains all frames from the error passed to `ifError()` including the potential new frames for `ifError()` itself.

  ```
  import assert from 'node:assert/strict';

  assert.ifError(null);
  // OK
  assert.ifError(0);
  // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
  assert.ifError('error');
  // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
  assert.ifError(new Error());
  // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error

  // Create some random error frames.
  let err;
  (function errorFrame() {
    err = new Error('test error');
  })();

  (function ifErrorFrame() {
    assert.ifError(err);
  })();
  // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
  //     at ifErrorFrame
  //     at errorFrame
  ```

  function [match](https://bun.com/reference/node/assert/default/match)(

  value: string,

  regExp: RegExp,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Expects the `string` input to match the regular expression.

  ```
  import assert from 'node:assert/strict';

  assert.match('I will fail', /pass/);
  // AssertionError [ERR_ASSERTION]: The input did not match the regular ...

  assert.match(123, /pass/);
  // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.

  assert.match('I will pass', /pass/);
  // OK
  ```

  If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.

  function [notDeepEqual](https://bun.com/reference/node/assert/default/notDeepEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  **Strict assertion mode**

  An alias of notDeepStrictEqual.

  **Legacy assertion mode**

  Stability: 3 - Legacy: Use notDeepStrictEqual instead.

  Tests for any deep inequality. Opposite of deepEqual.

  ```
  import assert from 'node:assert';

  const obj1 = {
    a: {
      b: 1,
    },
  };
  const obj2 = {
    a: {
      b: 2,
    },
  };
  const obj3 = {
    a: {
      b: 1,
    },
  };
  const obj4 = { __proto__: obj1 };

  assert.notDeepEqual(obj1, obj1);
  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

  assert.notDeepEqual(obj1, obj2);
  // OK

  assert.notDeepEqual(obj1, obj3);
  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

  assert.notDeepEqual(obj1, obj4);
  // OK
  ```

  If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [notDeepStrictEqual](https://bun.com/reference/node/assert/default/notDeepStrictEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Tests for deep strict inequality. Opposite of deepStrictEqual.

  ```
  import assert from 'node:assert/strict';

  assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
  // OK
  ```

  If the values are deeply and strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [notEqual](https://bun.com/reference/node/assert/default/notEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  **Strict assertion mode**

  An alias of notStrictEqual.

  **Legacy assertion mode**

  Stability: 3 - Legacy: Use notStrictEqual instead.

  Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is specially handled and treated as being identical if both sides are `NaN`.

  ```
  import assert from 'node:assert';

  assert.notEqual(1, 2);
  // OK

  assert.notEqual(1, 1);
  // AssertionError: 1 != 1

  assert.notEqual(1, '1');
  // AssertionError: 1 != '1'
  ```

  If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [notStrictEqual](https://bun.com/reference/node/assert/default/notStrictEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Tests strict inequality between the `actual` and `expected` parameters as determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).

  ```
  import assert from 'node:assert/strict';

  assert.notStrictEqual(1, 2);
  // OK

  assert.notStrictEqual(1, 1);
  // AssertionError [ERR_ASSERTION]: Expected "actual" to be strictly unequal to:
  //
  // 1

  assert.notStrictEqual(1, '1');
  // OK
  ```

  If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [ok](https://bun.com/reference/node/assert/default/ok)(

  value: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): asserts value;

  Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.

  If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`. If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.

  Be aware that in the `repl` the error message will be different to the one thrown in a file! See below for further details.

  ```
  import assert from 'node:assert/strict';

  assert.ok(true);
  // OK
  assert.ok(1);
  // OK

  assert.ok();
  // AssertionError: No value argument passed to `assert.ok()`

  assert.ok(false, 'it\'s false');
  // AssertionError: it's false

  // In the repl:
  assert.ok(typeof 123 === 'string');
  // AssertionError: false == true

  // In a file (e.g. test.js):
  assert.ok(typeof 123 === 'string');
  // AssertionError: The expression evaluated to a falsy value:
  //
  //   assert.ok(typeof 123 === 'string')

  assert.ok(false);
  // AssertionError: The expression evaluated to a falsy value:
  //
  //   assert.ok(false)

  assert.ok(0);
  // AssertionError: The expression evaluated to a falsy value:
  //
  //   assert.ok(0)
  ```

  ```
  import assert from 'node:assert/strict';

  // Using `assert()` works the same:
  assert(0);
  // AssertionError: The expression evaluated to a falsy value:
  //
  //   assert(0)
  ```

  function [partialDeepStrictEqual](https://bun.com/reference/node/assert/default/partialDeepStrictEqual)(

  actual: unknown,

  expected: unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Tests for partial deep equality between the `actual` and `expected` parameters. "Deep" equality means that the enumerable "own" properties of child objects are recursively evaluated also by the following rules. "Partial" equality means that only properties that exist on the `expected` parameter are going to be compared.

  This method always passes the same test cases as `assert.deepStrictEqual()`, behaving as a super set of it.

  function [rejects](https://bun.com/reference/node/assert/default/rejects)(

  block: Promise<unknown> | () => Promise<unknown>,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): Promise<void>;

  Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected.

  If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

  Besides the async nature to await the completion behaves identically to throws.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable `message` and `name` properties.

  If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.

  ```
  import assert from 'node:assert/strict';

  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    {
      name: 'TypeError',
      message: 'Wrong value',
    },
  );
  ```

  ```
  import assert from 'node:assert/strict';

  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    (err) => {
      assert.strictEqual(err.name, 'TypeError');
      assert.strictEqual(err.message, 'Wrong value');
      return true;
    },
  );
  ```

  ```
  import assert from 'node:assert/strict';

  assert.rejects(
    Promise.reject(new Error('Wrong value')),
    Error,
  ).then(() => {
    // ...
  });
  ```

  `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the example in throws carefully if using a string as the second argument gets considered.

  function [rejects](https://bun.com/reference/node/assert/default/rejects)(

  block: Promise<unknown> | () => Promise<unknown>,

  error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): Promise<void>;

  Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected.

  If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR\_INVALID\_RETURN\_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases the error handler is skipped.

  Besides the async nature to await the completion behaves identically to throws.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable `message` and `name` properties.

  If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.

  ```
  import assert from 'node:assert/strict';

  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    {
      name: 'TypeError',
      message: 'Wrong value',
    },
  );
  ```

  ```
  import assert from 'node:assert/strict';

  await assert.rejects(
    async () => {
      throw new TypeError('Wrong value');
    },
    (err) => {
      assert.strictEqual(err.name, 'TypeError');
      assert.strictEqual(err.message, 'Wrong value');
      return true;
    },
  );
  ```

  ```
  import assert from 'node:assert/strict';

  assert.rejects(
    Promise.reject(new Error('Wrong value')),
    Error,
  ).then(() => {
    // ...
  });
  ```

  `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the example in throws carefully if using a string as the second argument gets considered.

  function [strictEqual](https://bun.com/reference/node/assert/default/strictEqual)<T>(

  actual: unknown,

  expected: T,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): asserts actual is T;

  Tests strict equality between the `actual` and `expected` parameters as determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).

  ```
  import assert from 'node:assert/strict';

  assert.strictEqual(1, 2);
  // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
  //
  // 1 !== 2

  assert.strictEqual(1, 1);
  // OK

  assert.strictEqual('Hello foobar', 'Hello World!');
  // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
  // + actual - expected
  //
  // + 'Hello foobar'
  // - 'Hello World!'
  //          ^

  const apples = 1;
  const oranges = 2;
  assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);
  // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2

  assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));
  // TypeError: Inputs are not identical
  ```

  If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.

  function [throws](https://bun.com/reference/node/assert/default/throws)(

  block: () => unknown,

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Expects the function `fn` to throw an error.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable `message` and `name` properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.

  If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation fails.

  Custom validation object/error instance:

  ```
  import assert from 'node:assert/strict';

  const err = new TypeError('Wrong value');
  err.code = 404;
  err.foo = 'bar';
  err.info = {
    nested: true,
    baz: 'text',
  };
  err.reg = /abc/i;

  assert.throws(
    () => {
      throw err;
    },
    {
      name: 'TypeError',
      message: 'Wrong value',
      info: {
        nested: true,
        baz: 'text',
      },
      // Only properties on the validation object will be tested for.
      // Using nested objects requires all properties to be present. Otherwise
      // the validation is going to fail.
    },
  );

  // Using regular expressions to validate error properties:
  assert.throws(
    () => {
      throw err;
    },
    {
      // The `name` and `message` properties are strings and using regular
      // expressions on those will match against the string. If they fail, an
      // error is thrown.
      name: /^TypeError$/,
      message: /Wrong/,
      foo: 'bar',
      info: {
        nested: true,
        // It is not possible to use regular expressions for nested properties!
        baz: 'text',
      },
      // The `reg` property contains a regular expression and only if the
      // validation object contains an identical regular expression, it is going
      // to pass.
      reg: /abc/i,
    },
  );

  // Fails due to the different `message` and `name` properties:
  assert.throws(
    () => {
      const otherErr = new Error('Not found');
      // Copy all enumerable properties from `err` to `otherErr`.
      for (const [key, value] of Object.entries(err)) {
        otherErr[key] = value;
      }
      throw otherErr;
    },
    // The error's `message` and `name` properties will also be checked when using
    // an error as validation object.
    err,
  );
  ```

  Validate instanceof using constructor:

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    Error,
  );
  ```

  Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):

  Using a regular expression runs `.toString` on the error object, and will therefore also include the error name.

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    /^Error: Wrong value$/,
  );
  ```

  Custom error validation:

  The function must return `true` to indicate all internal validations passed. It will otherwise fail with an `AssertionError`.

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    (err) => {
      assert(err instanceof Error);
      assert(/value/.test(err));
      // Avoid returning anything from validation functions besides `true`.
      // Otherwise, it's not clear what part of the validation failed. Instead,
      // throw an error about the specific validation that failed (as done in this
      // example) and add as much helpful debugging information to that error as
      // possible.
      return true;
    },
    'unexpected error',
  );
  ```

  `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using a string as the second argument gets considered:

  ```
  import assert from 'node:assert/strict';

  function throwingFirst() {
    throw new Error('First');
  }

  function throwingSecond() {
    throw new Error('Second');
  }

  function notThrowing() {}

  // The second argument is a string and the input function threw an Error.
  // The first case will not throw as it does not match for the error message
  // thrown by the input function!
  assert.throws(throwingFirst, 'Second');
  // In the next example the message has no benefit over the message from the
  // error and since it is not clear if the user intended to actually match
  // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
  assert.throws(throwingSecond, 'Second');
  // TypeError [ERR_AMBIGUOUS_ARGUMENT]

  // The string is only used (as message) in case the function does not throw:
  assert.throws(notThrowing, 'Second');
  // AssertionError [ERR_ASSERTION]: Missing expected exception: Second

  // If it was intended to match for the error message do this instead:
  // It does not throw because the error messages match.
  assert.throws(throwingSecond, /Second$/);

  // If the error message does not match, an AssertionError is thrown.
  assert.throws(throwingFirst, /Second$/);
  // AssertionError [ERR_ASSERTION]
  ```

  Due to the confusing error-prone notation, avoid a string as the second argument.

  function [throws](https://bun.com/reference/node/assert/default/throws)(

  block: () => unknown,

  error: [AssertPredicate](https://bun.com/reference/node/assert/default/AssertPredicate),

  message?: string | [Error](https://bun.com/reference/globals/Error)

  ): void;

  Expects the function `fn` to throw an error.

  If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable `message` and `name` properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.

  If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation fails.

  Custom validation object/error instance:

  ```
  import assert from 'node:assert/strict';

  const err = new TypeError('Wrong value');
  err.code = 404;
  err.foo = 'bar';
  err.info = {
    nested: true,
    baz: 'text',
  };
  err.reg = /abc/i;

  assert.throws(
    () => {
      throw err;
    },
    {
      name: 'TypeError',
      message: 'Wrong value',
      info: {
        nested: true,
        baz: 'text',
      },
      // Only properties on the validation object will be tested for.
      // Using nested objects requires all properties to be present. Otherwise
      // the validation is going to fail.
    },
  );

  // Using regular expressions to validate error properties:
  assert.throws(
    () => {
      throw err;
    },
    {
      // The `name` and `message` properties are strings and using regular
      // expressions on those will match against the string. If they fail, an
      // error is thrown.
      name: /^TypeError$/,
      message: /Wrong/,
      foo: 'bar',
      info: {
        nested: true,
        // It is not possible to use regular expressions for nested properties!
        baz: 'text',
      },
      // The `reg` property contains a regular expression and only if the
      // validation object contains an identical regular expression, it is going
      // to pass.
      reg: /abc/i,
    },
  );

  // Fails due to the different `message` and `name` properties:
  assert.throws(
    () => {
      const otherErr = new Error('Not found');
      // Copy all enumerable properties from `err` to `otherErr`.
      for (const [key, value] of Object.entries(err)) {
        otherErr[key] = value;
      }
      throw otherErr;
    },
    // The error's `message` and `name` properties will also be checked when using
    // an error as validation object.
    err,
  );
  ```

  Validate instanceof using constructor:

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    Error,
  );
  ```

  Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):

  Using a regular expression runs `.toString` on the error object, and will therefore also include the error name.

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    /^Error: Wrong value$/,
  );
  ```

  Custom error validation:

  The function must return `true` to indicate all internal validations passed. It will otherwise fail with an `AssertionError`.

  ```
  import assert from 'node:assert/strict';

  assert.throws(
    () => {
      throw new Error('Wrong value');
    },
    (err) => {
      assert(err instanceof Error);
      assert(/value/.test(err));
      // Avoid returning anything from validation functions besides `true`.
      // Otherwise, it's not clear what part of the validation failed. Instead,
      // throw an error about the specific validation that failed (as done in this
      // example) and add as much helpful debugging information to that error as
      // possible.
      return true;
    },
    'unexpected error',
  );
  ```

  `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using a string as the second argument gets considered:

  ```
  import assert from 'node:assert/strict';

  function throwingFirst() {
    throw new Error('First');
  }

  function throwingSecond() {
    throw new Error('Second');
  }

  function notThrowing() {}

  // The second argument is a string and the input function threw an Error.
  // The first case will not throw as it does not match for the error message
  // thrown by the input function!
  assert.throws(throwingFirst, 'Second');
  // In the next example the message has no benefit over the message from the
  // error and since it is not clear if the user intended to actually match
  // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
  assert.throws(throwingSecond, 'Second');
  // TypeError [ERR_AMBIGUOUS_ARGUMENT]

  // The string is only used (as message) in case the function does not throw:
  assert.throws(notThrowing, 'Second');
  // AssertionError [ERR_ASSERTION]: Missing expected exception: Second

  // If it was intended to match for the error message do this instead:
  // It does not throw because the error messages match.
  assert.throws(throwingSecond, /Second$/);

  // If the error message does not match, an AssertionError is thrown.
  assert.throws(throwingFirst, /Second$/);
  // AssertionError [ERR_ASSERTION]
  ```

  Due to the confusing error-prone notation, avoid a string as the second argument.